input {
  # Lecture des fichiers NDJSON (une ligne par objet JSON)
  file {
    path => "/usr/share/logstash/data/transactions.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "transaction"
  }

  file {
    path => "/usr/share/logstash/data/errors.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "error"
  }

  file {
    path => "/usr/share/logstash/data/fraud.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "fraud"
  }

  file {
    path => "/usr/share/logstash/data/performance.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "performance"
  }

  file {
    path => "/usr/share/logstash/data/user_behavior.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "user_behavior"
  }

  # Lecture des fichiers CSV
  file {
    path => "/usr/share/logstash/data/transactions.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "transaction"
  }

  file {
    path => "/usr/share/logstash/data/errors.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "error"
  }

  file {
    path => "/usr/share/logstash/data/fraud.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "fraud"
  }

  file {
    path => "/usr/share/logstash/data/performance.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "performance"
  }

  file {
    path => "/usr/share/logstash/data/user_behavior.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "user_behavior"
  }
}

filter {
  # Parser CSV selon la structure rÃ©elle des fichiers
  if [log][file][path] =~ /\.csv$/ {
    if [type] == "transaction" {
      csv {
        source => "message"
        separator => ","
        columns => ["timestamp", "event", "order_id", "user", "amount", "method", "duration_ms"]
      }
      mutate {
        convert => {
          "amount" => "float"
          "duration_ms" => "integer"
        }
        remove_field => ["message"]
      }
    }
    else if [type] == "error" {
      csv {
        source => "message"
        separator => ","
        columns => ["timestamp", "status", "endpoint", "error_message"]
      }
      mutate {
        convert => {
          "status" => "integer"
        }
        remove_field => ["message"]
      }
    }
    else if [type] == "fraud" {
      csv {
        source => "message"
        separator => ","
        columns => ["timestamp", "event", "user", "ip", "attempts"]
      }
      mutate {
        convert => {
          "attempts" => "integer"
        }
        remove_field => ["message"]
      }
    }
    else if [type] == "performance" {
      csv {
        source => "message"
        separator => ","
        columns => ["timestamp", "event", "endpoint", "latency_ms", "status"]
      }
      mutate {
        convert => {
          "latency_ms" => "integer"
          "status" => "integer"
        }
        remove_field => ["message"]
      }
    }
    else if [type] == "user_behavior" {
      csv {
        source => "message"
        separator => ","
        columns => ["timestamp", "event", "user", "page"]
      }
      mutate {
        remove_field => ["message"]
      }
    }
  }

  # Parser le timestamp
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss'Z'", "yyyy-MM-dd'T'HH:mm:ssZ", "yyyy-MM-dd HH:mm:ss"]
      target => "@timestamp"
    }
  }

  # DÃ©terminer l'index de destination
  if [type] == "transaction" {
    mutate {
      add_field => { "[@metadata][index]" => "ecommerce-transactions" }
    }
  } else if [type] == "error" {
    mutate {
      add_field => { "[@metadata][index]" => "ecommerce-errors" }
    }
  } else if [type] == "fraud" {
    mutate {
      add_field => { "[@metadata][index]" => "ecommerce-fraud" }
    }
  } else if [type] == "performance" {
    mutate {
      add_field => { "[@metadata][index]" => "ecommerce-performance" }
    }
  } else if [type] == "user_behavior" {
    mutate {
      add_field => { "[@metadata][index]" => "ecommerce-user-behavior" }
    }
  }

  # Nettoyer les champs inutiles
  mutate {
    remove_field => ["path", "host"]
  }
}

output {
  # Envoyer vers Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index]}"
    document_type => "_doc"
  }

  # Debug output
  stdout {
    codec => rubydebug
  }
}

# Pipeline Logstash pour fichiers CSV - Transactions E-Commerce
# Surveille le dossier /data/csv/ pour les fichiers de transactions

input {
  file {
    # Surveiller le dossier CSV pour les nouveaux fichiers
    path => "/usr/share/logstash/input_data/csv/*.csv"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/logs/sincedb_csv"
    
    # Mode de découverte des fichiers - tail surveille en continu
    mode => "tail"
    
    # Codec pour lire ligne par ligne
    codec => plain
    
    # Tags pour identification
    tags => ["csv", "transactions", "ecommerce"]
    
    # Type de fichier
    type => "transaction_csv"
  }
}

filter {
  # Ignorer les lignes vides et les commentaires
  if [message] =~ /^\s*$/ or [message] =~ /^#/ {
    drop { }
  }
  
  # Parser le CSV avec gestion d'erreurs
  csv {
    separator => ","
    skip_header => true
    columns => [
      "transactionId",
      "userId", 
      "timestamp",
      "amount",
      "currency",
      "status",
      "paymentMethod",
      "productId",
      "productName",
      "quantity",
      "price",
      "shippingAddress",
      "billingAddress",
      "ipAddress",
      "userAgent"
    ]
  }
  
  # Si parsing CSV a échoué, taguer et logger
  if "_csvparsefailure" in [tags] {
    mutate {
      add_field => { 
        "parse_error" => "Failed to parse CSV line"
        "original_message" => "%{message}"
      }
      add_tag => ["parse_error"]
    }
  } else {
    # Conversion des types de données
    mutate {
      convert => {
        "amount" => "float"
        "quantity" => "integer"
        "price" => "float"
      }
      
      # Retirer le message brut une fois parsé
      remove_field => ["message"]
    }
    
    # Parser la date/timestamp
    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "UNIX"]
      target => "@timestamp"

    }
    
    # Enrichissement : calculer le montant total
    ruby {
      code => '
        quantity = event.get("quantity").to_i
        price = event.get("price").to_f
        event.set("totalAmount", quantity * price)
      '
      tag_on_exception => "_rubyexception"
    }
    
    # Enrichissement : détection de fraude basique
    if [amount] {
      ruby {
        code => '
          amount = event.get("amount").to_f
          # Marquer comme suspect si montant > 10000
          if amount > 10000
            event.set("fraud_risk_level", "high")
            event.set("fraud_reason", "High transaction amount")
          elsif amount > 5000
            event.set("fraud_risk_level", "medium")
          else
            event.set("fraud_risk_level", "low")
          end
        '
      }
    }
    
    # Extraction de l'information géographique depuis l'IP (si disponible)
    if [ipAddress] and [ipAddress] != "" {
      geoip {
        source => "ipAddress"
        target => "geoip"

      }
      
      # Si la géolocalisation a réussi, ajouter des informations supplémentaires
      if "_geoip_lookup_failure" not in [tags] {
        mutate {
          add_field => {
            "country" => "%{[geoip][country_name]}"
            "city" => "%{[geoip][city_name]}"
            "location_lat" => "%{[geoip][latitude]}"
            "location_lon" => "%{[geoip][longitude]}"
          }
        }
      }
    }
    
    # Parser le User Agent pour obtenir des infos sur le navigateur/OS
    if [userAgent] and [userAgent] != "" {
      useragent {
        source => "userAgent"
        target => "user_agent"

      }
    }
    
    # Enrichissement : catégorisation du statut
    if [status] {
      mutate {
        lowercase => ["status"]
      }
      
      # Ajouter des tags selon le statut
      if [status] == "completed" or [status] == "success" {
        mutate {
          add_tag => ["transaction_success"]
        }
      } else if [status] == "failed" or [status] == "declined" {
        mutate {
          add_tag => ["transaction_failed"]
        }
      } else if [status] == "pending" {
        mutate {
          add_tag => ["transaction_pending"]
        }
      }
    }
    
    # Enrichissement : normalisation de la devise
    if [currency] {
      mutate {
        uppercase => ["currency"]
      }
    }
    
    # Enrichissement : extraction du domaine de l'email si userId est un email
    if [userId] =~ /@/ {
      grok {
        match => { "userId" => "%{EMAILADDRESS:email}" }

      }
      
      if [email] {
        grok {
          match => { "email" => "@%{DATA:email_domain}" }

        }
      }
    }
    
    # Ajouter des métadonnées
    mutate {
      add_field => {
        "[@metadata][index_name]" => "ecommerce_transactions"
        "[@metadata][document_type]" => "transaction"
        "logType" => "transaction"
        "source" => "csv_pipeline"
        "processed_at" => "%{@timestamp}"
      }
    }
  }
}

output {
  # Output vers Elasticsearch
  if "_csvparsefailure" not in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch:9200}"]
      index => "ecommerce_transactions-%{+YYYY.MM.dd}"
      document_id => "%{transactionId}"
      
      # Gestion des erreurs d'écriture
      action => "index"
      
      # Configuration de retry
      retry_on_conflict => 5
      
      # Gestion des erreurs
      manage_template => false
    }
  }
  
  # Envoyer les erreurs de parsing dans un index séparé
  if "_csvparsefailure" in [tags] or "parse_error" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOST:elasticsearch:9200}"]
      index => "ecommerce_errors-%{+YYYY.MM.dd}"
      
      manage_template => false
    }
  }
  
  # Log pour debugging (optionnel, peut être commenté en production)
  if [@metadata][debug] {
    stdout {
      codec => rubydebug {
        metadata => true
      }
    }
  }
}

